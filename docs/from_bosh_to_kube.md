# Transforming BOSH concepts to Kubernetes

- [Transforming BOSH concepts to Kubernetes](#transforming-bosh-concepts-to-kubernetes)
  - [High-level Direction](#high-level-direction)
  - [Deployment Lifecycle](#deployment-lifecycle)
    - [Create](#create)
    - [Update](#update)
    - [Delete](#delete)
  - [Open Questions and TODOs](#open-questions-and-todos)
  - [Example Deployment Manifest Conversion Details](#example-deployment-manifest-conversion-details)
  - [BPM](#bpm)
    - [Entrypoint & Environment Variables](#entrypoint--environment-variables)
    - [Resources](#resources)
  - [Healthchecks](#healthchecks)
  - [Conversion Details](#conversion-details)
    - [Calculation of docker image location for releases](#calculation-of-docker-image-location-for-releases)
    - [Variables to Extended Secrets](#variables-to-extended-secrets)
    - [Instance Groups to Extended StatefulSets and Jobs](#instance-groups-to-extended-statefulsets-and-jobs)
      - [BOSH Services vs BOSH Errands](#bosh-services-vs-bosh-errands)
      - [Naming, Labels and Annotations](#naming-labels-and-annotations)
      - [Containers](#containers)
      - [Mounts](#mounts)
      - [Entrypoints](#entrypoints)
  - [Other](#other)

## High-level Direction

- releases are defined in the usual way (a `releases` block), but the information given is used to build a reference for a docker image
- a release in the `releases` block can have credentials for the registry
- each instance group can be transformed to an `ExtendedStatefulSet` or an `ExtendedJob`
- each BOSH Job corresponds to a container in the pod defined in the `ExtendedStatefulSet` or the `ExtendedJob`
- `variables` are generated using `ExtendedSecrets`
- [rendering of BOSH Job Templates](rendering_templates.md) requires mounting the current version of the [Desired Manifest](desired_manifests.md) and all secrets corresponding to variables
- all communication happens through `Services`, which have deterministic DNS Addresses
- links are resolved using services

## Deployment Lifecycle

### Create

1. First, `ExtendedSecrets` are created
2. `ExtendedJobs` for template rendering are created (we wait until this is complete, because we need BPM information to move forward)
3. Volumes are created
4. `ExtendedJobs` for errands are created
5. `ExtendedStatefulSets` are created
6. `ExtendedServices` are created

### Update

> Resources are identified by their name.

1. New resources are created, in the same order as `Create`
2. An update is issued for resources that already exist
3. Any resources that are no longer needed are deleted

### Delete

As the `BOSHDeployment` is deleted, all owned resources are automatically deleted.

## Open Questions and TODOs

1. Detailed specification for dealing with AZs
2. How do we specify credentials for docker registries containing release images?
   - we could extend the deployment manifest schema (with agreement from the BOSH team)
   - we could have a special k8s secret, which by convention is always named something like `docker-registry-secrets` and contains hostnames-to-credential mappings. e.g.:

     ```text
     docker.io: { user: test, password: none }
     localhost: { user: root, password, toor }
     ```

3. Are we going to use ephemeral disks? Are they useful?
4. BOSH makes use of errands, which are manually triggered. How do we support this in ExtendedJob?
5. Discuss the ability to extend the releases block with credentials.
6. Details on how we create services for jobs
7. How do we rename things?
8. Do we need ephemeral disks?
9. For persistent disks - are they shared among container pods?
10. Canary support in ExtendedStatefulSets
11. How do we deal with volumes? How can data be migrated from an older volume? Can we use ExtendedJobs for this? Do we need `ExtendedPersistentVolumes`?
12. How are readiness probes generated?

## Example Deployment Manifest Conversion Details

```yaml
---
# The name of the deployment. Replace the name with the name of the BOSHDeployment resource
# It's used to namespace resources created for this deployment.
# Based on docs [1], names should be less than 253 characters. We should limit this to
# characters in the operator, to make sure that with any suffix, we won't go beyond the limit.
name: "foo"
# Not used by the cf-operator.
# A warning is printed in the logs if this is present.
director_uuid: "bar"
# A hash of director features. We could use this to control operator features as well.
features:
  # Enable variables to be regenerated by the config server (e.g. CredHub) when the variable options change. Default false.
  # In the cf-operator, if an ExtendedSecret is changed, (e.g. a new domain is added to a cert),
  # the value will be automatically updated.
  # The operator won't be able to control this behavior.
  # A warning is printed in the logs if this is present.
  converge_variables: true
  # Randomizes AZs for left over instances that cannot be distributed equally between AZs.
  # Not currently used. It's likely that we'll be able to support this.
  randomize_az_placement: false
  # Enables or disables returning of DNS addresses in links.
  # In Kubernetes we always use DNS addresses.
  # An error should be returned if this value is set to false.
  use_dns_addresses: true
# A list of all releases used in this deployment.
# Required.
# Each release's image reference is constructed from this information like this:
# <url>/<name>:<stemcell.os>-<stemcell.version>-<version>
releases:
  # Name of a release used in the deployment.
  name: "capi-release"
  # The version of the release to be used.
  # "latest" is not supported by the cf-operator. An error is thrown if "latest" is used.
  version: "1.0"
  # Required for the operator. Link to the registry and organization containing the image.
  url: "docker.io/cloudfoundry"
  # Not used by the cf-operator.
  # Integrity of the image itself is handled by whatever
  # container runtime and the image registry.
  sha1: "332ac15609b220a3fdf5efad0e0aa069d8235788"
  # Required by the operator
  stemcell:
    # OS of the stemcell used by the release. Used to construct the image name.
    os: "opensuse"
    # Version of the OS of the stemcell used by the release.
    version: "42.3"
  # Only used by the cf-operator.
  # A secret is created with the credentials [2], used by the pods
  # that reference this release.
  credentials:
    username: "foo"
    password: "secret"
# Not used by the cf-operator.
# A warning is logged if this is set
stemcells: []
# Specifies how updates are handled
# The cf-operator uses some of these settings.
update:
  # The number of pods to deploy in the new version of an ExtendedStatefulSet
  # Once canaries are running, deployment can continue.
  # TODO: Support for canaries needs implementation in ExtendedStatefulSet.
  canaries: 2
  # Time to wait for canary pods to be ready in a new version of an ExtendedStatefulSet
  canary_watch_time: 100
  # The maximum number of non-canary instances to update in parallel for an ExtendedStatefulSet.
  # TODO: Support for this needs to be implemented in the controller.
  max_in_flight: 2
  # TODO: is there a need for this in ExtendedStatefulSet (in a readiness Probe?)
  update_watch_time: 0
  # Not used in cf-operator.
  # All instance groups are deployed at the same time.
  # If set to true, a warning is logged.
  serial: false
  # Not used in cf-operator.
  # If set, a warning is logged.
  vm_strategy: ""
# Each instance group is converted into an ExtendedStatefulSet
instance_groups:
  # Used to name the ExtendedStatefulSet or ExtendedJob
- name: "api-az1"
  # TODO: how do we use this in conjunction with node labels? (exact procedure)
  azs: ["az1"]
  # Number of replicas for the StatefulSets in an ExtendedStatefulSet
  # If this instance group defines an ExtendedJob, this value must be 1. An error is thrown otherwise
  instances: 3
  # Each job results in a rendered bpm.yml file.
  # BPM information is required - the deployment fails if it's missing.
  # Each job has one or more processes (defined in bpm.yml), and each   corresponds to a container of a pod in a StatefulSet or Job
  jobs:
    # It's used to name the container
  - name: "cloud_controller_ng"
    # The name of a release that must exist in the releases block.
    # If it doesn't exist in the releases block, an error is thrown.
    # The docker image used for the container is resolved using this release name.
    release: "capi-release"
    # Used by the cf-operator to calculate links before rendering templates.
    # All resources in the cf-operator are deterministic (IP addresses are not used),
    # So they can be calculated before template rendering occurs.
    consumes: {}
    # Same as the consumes block above.
    provides: {}
    # Defines all properties, used to render job templates.
    # Job templates are rendered as Secrets, and then mounted into pod containers.
    # If a property is changed, the operator runs rendering in an ExtendedJob, and the
    # template's secret is (re)generated.
    # All properties are input to this ExtendedJob that does rendering.
    # Some properties can reference variables, which are generated. The cf-operator
    # collects values for all properties before starting the rendering process.
    properties:
      domain: "mycf.com"
      admin_password: "((adminpass))"
      # Extra information specific to the cf-operator
      bosh_containerization:
        run:
          # Hints for pod replica count
          scaling:
            min: 1
            max: 3
            ha: 2
          # Extra capabilities required by the containers of this job
          capabilities: []
          # Memory used by each container. Overrides info from vm_resources.
          memory: 128
          # Number of vCPUs used by each container. Overrides info from vm_resources.
          virtual-cpus: 2
          # Healthcheck information for the containers in this job.
          healthcheck:
            some_process_name:
              readiness:
                handler:
                  exec:
                    command:
                    - "curl --silent --fail --head http://${HOSTNAME}:8080/health"
        # List of ports to be opened up for this job.
        ports:
        - name: "health-port"
          protocol: "TCP"
          internal: 8080
  # Not used by the cf-operator.
  # A warning is logged if this is set.
  vm_type: ""
  # Not used by the cf-operator.
  # A warning is logged if this is set.
  vm_extensions: []
  # Used by the cf-operator to limit the resources used by a container in a pod
  vm_resources:
    # Number of vCPUs used by a container
    cpu: 4
    # Memory used by a container
    ram: 1024
    # TODO: figure out if we need to use ephemeral disks
    ephemeral_disk_size: 4096
  # Not used by the cf-operator.
  # A warning is logged if this is set.
  stemcell: ""
  # Size of the volume attached to a pod container.
  # TODO: understand if this needs to be a shared volume, attached to each container,
  # or a separate volume for each container.
  persistent_disk: 4096
  # This must be the name of a StorageClass used by the cf-operator to create volumes.
  persistent_disk_type: "default"
  # Not used by the cf-operator.
  # A warning is logged if this key is set.
  networks:
    # Not used by the cf-operator
    - name: "foo"
      # Not used by the cf-operator
      static_ips: []
      # Not used by the cf-operator
      default: []
  # Specific update settings for this instance group. Use this to override global job update settings on a per-instance-group basis.
  update: {}
  # TODO: understand how instance group renames can occur in an ExtendedStatefulSet or ExtendedJob
  migrated_from:
  - cloud_controller
  # This is the key that controls how an instance group is treated by the cf-operator.
  # If lifecycle is "service", an ExtendedStatefulSet is created for the instance group.
  # Otherwise, if it's "errand", an ExtendedJob is created. As with normal BOSH, errands have a
  # manual trigger, so ExtendedJobs have to support this (manual triggers).
  # In Kubernetes we also need errands that can run on a trigger. These are not supported by BOSH.
  # The lifecycle for such an ExtendedJob is "auto-errand".
  # TODO: how are manual triggers handled?
  lifecycle: "service"
  # Deprecated - the cf-operator does not support this key.
  # An error is thrown if this is set.
  properties: {}
  # Usually used for BOSH Agent configuration.
  # We can use this hash to control how the operator generates resources, however
  # none of the settings used by the Agent are supported by the operator.
  env:
    # Not used by the cf-operator.
    # A warning is logged if this is set.
    persistent_disk_fs: "ext4"
    # Not used by the cf-operator.
    # A warning is logged if this is set.
    persistent_disk_mount_options: []
    # Not used by the cf-operator.
    # A warning is logged if this is set.
    bosh [Hash, optional]:
      # Not used by the cf-operator.
      # A warning is logged if this is set.
      password: "foo"
      # Not used by the cf-operator.
      # A warning is logged if this is set.
      keep_root_password: vcap
      # Not used by the cf-operator.
      # A warning is logged if this is set.
      remove_dev_tools: false
      # Not used by the cf-operator.
      # A warning is logged if this is set.
      remove_static_libraries: false.
      # Not used by the cf-operator.
      # A warning is logged if this is set.
      swap_size: 100
      # Not used by the cf-operator.
      # A warning is logged if this is set.
      ipv6:
        # Not used by the cf-operator.
        # A warning is logged if this is set.
        enable: false
      # Not used by the cf-operator.
      # A warning is logged if this is set.
      job_dir:
        # Not used by the cf-operator.
        # A warning is logged if this is set.
        tmpfs: false
        # Not used by the cf-operator.
        # A warning is logged if this is set.
        tmpfs_size: "0m"
      agent:
        # Not used by the cf-operator.
        # A warning is logged if this is set.
        tmpfs: false
        # Used by the cf-operator to set kubernetes-specific information
        # for the resources representing this instance group.
        settings:
          # Affinity information for this instance group's pod.
          # These definitions are merged directly into the pod's definition.
          # The structure is the same as the one used by Kube [3].
          affinity: {}
          # Labels to add to the resources representing the instance group
          labels: {}
          # Annotations to add to the resources representing the instance group
          annotations: {}
# Addons are not currently supported by the cf-operator.
# A warning is logged if this is set.
addons: []
# Deprecated - the cf-operator does not support this key.
# An error is thrown if this is set.
properties: {}
# For each variable, the cf-operator creates ExtendedSecrets
# As with normal BOSH, variables are referenced by job properties.
# Each variable's generated secret is mounted in the container that renders each job's
# templates. They are then used by the rendering process.
# This means that the operator needs to look at the job's properties, and parse any references
# to variables, so it knows what it needs to mount.
variables:
    # Unique name used to identify a variable. Used to name the ExtendedSecret
  - name: "adminPass"
    # As with normal BOSH, supported types are certificate, password, rsa, and ssh.
    type: "password"
    # Specifies generation options
    options: {is_ca: true, common_name: "some-ca"}
# Tags are transformed into annotations for the resources created
# by this deployment.
tags:
  maintainer: "Philip J. Fry"
```

- [1] https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
- [2] https://kubernetes.io/docs/tasks/configure-pod-container/pull-image-private-registry/
- [3] https://kubernetes.io/docs/concepts/configuration/assign-pod-node/#affinity-and-anti-affinity

## BPM

In a BOSH release some jobs have BPM configuration in `templates/bpm.yml.erb`. These BPM configs are converted into containers. For instance groups of the type `service` the containers are added to the `ExtendedStatefulSet`'s, for `errands` to the `ExtendedJob`'s pods.
Each `process` specified in the BPM configuration is run in a single Kubernetes `container` as part of a pod.

The following subsections describe the mapping of BPM configuration into containers.

### Entrypoint & Environment Variables

Bosh             | Kube Pod Container |
--------------- | ---- |
`executable`        | `command` |
`args`              | `args` |
`env`              | `env` |

### Resources

Bosh             | Kube Pod Container |
--------------- | ---- |
`workdir`             | `workingDir`. Not Supported. |
`hooks`               | `Not Supported` |
`capabilities`        | `container.SecurityContext.Capabilities`. Not yet supported.  |
`limits`              | `container.Resources.Limits`. Not yet supported. |
`ephermeral_disk`     | Not Supported. |
`persistent_disk`     | Supported. |
`additional_volumes`  | maps to `VolumeClaimTemplates` which creates Persistent Volume claims in kube cluster. Not yet supported. |
`unsafe`              | Unmapped to Kubernetes resources. Can be programmatically supported. Not yet supported. |

## Healthchecks

BPM doesn't provide information for health checks and relies on monit instead. CF-Operator provides health checks via the [BOSHContainerization](https://github.com/cloudfoundry-incubator/cf-operator/blob/2cab6516e8a3fc1f0c814554912449b88dee3101/pkg/bosh/manifest/containerization.go#L7-L13) property in the deployment manifest.

Healthcheck is used for checking the status of the BPM process's using liveness and readiness as defined in Kubernetes [docs](https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-probes/).

Bosh             | Kube Pod Container |
--------------- | ---- |
`liveness` defined in properties of the Instance group job per BPM process.   | `livenessProbe`. Not Supported. |
`readiness` defined in properties of the Instance group job per BPM process.  | `readinessProbe` Not Supported. |


## Conversion Details

### Calculation of docker image location for releases

The release image locations are comprised of multiple elements: the docker registry URL, the organization and repository, the stemcell name and version, the fissile version and the release name and version. Release image locations always have to be resolved in the context of an instance group/job because it depends on the stemcell that is being used.

A typical release image location looks could look like `hub.docker.com/cfcontainerization/cflinuxfs3-release:opensuse-15.0-28.g837c5b3-30.263-7.0.0_233.gde0accd0-0.62.0`.

The different elements are taken from different places in the manifest. Given this excerpt from a BOSH deployment manifest:

```yaml
stemcells:
- alias: default
  os: opensuse-42.3
  version: 28.g837c5b3-30.263-7.0.0_234.gcd7d1132
instance_groups:
- name: diego-cell
  stemcell: default
  jobs:
  - name: cflinuxfs3-rootfs-setup
    release: cflinuxfs3
releases:
- name: cflinuxfs3
  version: 0.62.0
  url: hub.docker.com/cfcontainerization
  sha1: 6466c44827c3493645ca34b084e7c21de23272b4
  stemcell:
    os: opensuse-15.0
    version: 28.g837c5b3-30.263-7.0.0_233.gde0accd0
```

The stemcell information (name, and stemcell and fissile version) are taken from the `stemcells` entry that matches the instance group's stemcell alias. The registry URL including the organization, the release name, and the version com from the `releases` entry that's referenced from the job.

> *Note*: Releases can optionally specify a separate `stemcell` section, in which case the information from the instance group stemcell is overridden.

### Variables to Extended Secrets

For each **BOSH Variable**, the cf-operator creates `ExtendedSecrets`.
The `ExtendedSecret` is meant to generate the value required by the variable.

The name of the `ExtendedSecret` is calculated like this:

```text
<DEPLOYMENT_NAME>.<VARIABLE_NAME>
```

The name of the final generated `Secret` (the `secretName` key) is calculated the same way.

The deployment name and variable name can only consist of lowercase alphanumeric characters, and the character `"-"`.
All `"_"` characters are replaced with `"-"`. All other non-alphanumeric characters are removed.

The secret name cannot start or end with a `"-"`. These characters are trimmed.

Secret names are also restricted to 63 characters in length, so if a generated name exceeds 63 characters, it should be recalculated as:

```text
name=<DEPLOYMENT_NAME>-<VARIABLE_NAME>

<name trimmed to 31 characters><md5 hash of name>
```

### Instance Groups to Extended StatefulSets and Jobs

#### BOSH Services vs BOSH Errands

BOSH Services are converted to `ExtendedStatefulSets`.

BOSH Errands are converted to `ExtendedJobs` with `trigger.strategy: manually`.

BOSH Auto-Errands (supported only by the operator) are converted to `ExtendedJobs` with `trigger.strategy: once`.

#### Naming, Labels and Annotations

Name:

```text
<deployment-name>-<instance-group-name>
```

Labels:

```yaml
fissile.cloudfoundry.org/deployment-name: "<deployment-name>"
fissile.cloudfoundry.org/instance-group-name: "<instance-group-name>"
fissile.cloudfoundry.org/deployment-version: "<integer version of the desired manifest>"
```

Annotations:

```yaml
fissile.cloudfoundry.org/?
```

#### Containers

Each pod (for either an `ExtendedStatefulSet` or `ExtendedJob`) contains one container for each BOSH Job that's part of its instance group.

#### Mounts

- **desired manifest**
- **bosh variable secrets**
- **user configmaps** for variables that are not generated
- data volumes

#### Entrypoints

## Other

These need to be provided by a mount in each container,

- `/var/vcap/instance/name`
- `/var/vcap/instance/id`
